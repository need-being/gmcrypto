package sm2

import (
	"crypto/elliptic"
	"math/big"
)

// instance represents an SM2 curve.
var instance = &curve{
	P: new(big.Int).SetBytes([]byte{
		0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}),
	A: new(big.Int).SetBytes([]byte{
		0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
	}),
	B: new(big.Int).SetBytes([]byte{
		0x28, 0xe9, 0xfa, 0x9e, 0x9d, 0x9f, 0x5e, 0x34,
		0x4d, 0x5a, 0x9e, 0x4b, 0xcf, 0x65, 0x09, 0xa7,
		0xf3, 0x97, 0x89, 0xf5, 0x15, 0xab, 0x8f, 0x92,
		0xdd, 0xbc, 0xbd, 0x41, 0x4d, 0x94, 0x0e, 0x93,
	}),
	N: new(big.Int).SetBytes([]byte{
		0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x72, 0x03, 0xdf, 0x6b, 0x21, 0xc6, 0x05, 0x2b,
		0x53, 0xbb, 0xf4, 0x09, 0x39, 0xd5, 0x41, 0x23,
	}),
	Gx: new(big.Int).SetBytes([]byte{
		0x32, 0xc4, 0xae, 0x2c, 0x1f, 0x19, 0x81, 0x19,
		0x5f, 0x99, 0x04, 0x46, 0x6a, 0x39, 0xc9, 0x94,
		0x8f, 0xe3, 0x0b, 0xbf, 0xf2, 0x66, 0x0b, 0xe1,
		0x71, 0x5a, 0x45, 0x89, 0x33, 0x4c, 0x74, 0xc7,
	}),
	Gy: new(big.Int).SetBytes([]byte{
		0xbc, 0x37, 0x36, 0xa2, 0xf4, 0xf6, 0x77, 0x9c,
		0x59, 0xbd, 0xce, 0xe3, 0x6b, 0x69, 0x21, 0x53,
		0xd0, 0xa9, 0x87, 0x7c, 0xc6, 0x2a, 0x47, 0x40,
		0x02, 0xdf, 0x32, 0xe5, 0x21, 0x39, 0xf0, 0xa0,
	}),
}

// Curve returns an elliptic curve for SM2.
func Curve() elliptic.Curve {
	return instance
}

// curve is an SM2 elliptic curve structure.
type curve struct {
	P  *big.Int
	A  *big.Int
	B  *big.Int
	N  *big.Int
	Gx *big.Int
	Gy *big.Int
}

// Params returns the parameters for the curve.
// It panics since methods associated with *elliptic.CurveParams cannot be
// applied to the SM2 curve.
func (curve *curve) Params() *elliptic.CurveParams {
	panic("sm2: incompatible with *elliptic.CurveParams")
}

// IsOnCurve reports whether the given (x,y) lies on the curve.
func (curve *curve) IsOnCurve(x *big.Int, y *big.Int) bool {
	if x.Sign() < 0 || x.Cmp(curve.P) >= 0 || y.Sign() < 0 || y.Cmp(curve.P) >= 0 {
		return false
	}

	// SM2 polynomial: y² = x³ + ax + b
	y2 := new(big.Int).Mul(y, y)
	y2.Mod(y2, curve.P)

	return curve.polynomial(x).Cmp(y2) == 0
}

// polynomial returns x³ + ax + b.
func (curve *curve) polynomial(x *big.Int) *big.Int {
	// x³ + ax + b = (x² + a)x + b
	res := new(big.Int).Mul(x, x)
	res.Add(res, curve.A)
	res.Mod(res, curve.P)

	res.Mul(res, x)
	res.Add(res, curve.B)
	res.Mod(res, curve.P)

	return res
}

// Add returns the sum of (x1,y1) and (x2,y2)
func (curve *curve) Add(x1 *big.Int, y1 *big.Int, x2 *big.Int, y2 *big.Int) (x *big.Int, y *big.Int) {
	panic("not implemented") // TODO: Implement
}

// Double returns 2*(x,y)
func (curve *curve) Double(x1 *big.Int, y1 *big.Int) (x *big.Int, y *big.Int) {
	panic("not implemented") // TODO: Implement
}

// ScalarMult returns k*(Bx,By) where k is a number in big-endian form.
func (curve *curve) ScalarMult(x1 *big.Int, y1 *big.Int, k []byte) (x *big.Int, y *big.Int) {
	panic("not implemented") // TODO: Implement
}

// ScalarBaseMult returns k*G, where G is the base point of the group
// and k is an integer in big-endian form.
func (curve *curve) ScalarBaseMult(k []byte) (x *big.Int, y *big.Int) {
	return curve.ScalarMult(curve.Gx, curve.Gy, k)
}
